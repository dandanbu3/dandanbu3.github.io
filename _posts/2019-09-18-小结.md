---
layout: post
title: 小结
---

1.with: JavaScript查找某个未使用命名空间的变量时，会通过作用域链来查找，作用域链是跟执行代码的context或者包含这个变量的函数有关。'with'语句將某个对象添加到作用域链的顶部，如果在statement中有某个未使用命名空间的变量，跟作用域链中的某个属性同名，则这个变量将指向这个属性值。
2.JavaScript 中有两个机制可以“欺骗”词法作用域：eval(..) 和 with。前者可以对一段包 含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在 运行时）。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作 用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）
3.函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复 用（事实上在嵌套的作用域中也可以使用）。这种设计方案是非常有用的，能充分利用 JavaScript 变量可以根据需要改变值类型的“动态”特性

4.区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位 置（不仅仅是一行代码，而是整个声明中的位置）。如果 function 是声明中 的第一个词，那么就是一个函数声明，否则就是一个函数表达式

5.函数声明和变量声明都会被提升。但是一个值得注意的细节是函数会首先被提升，然后才是变量

6.作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法 作用域，我们会对这种作用域进行深入讨论。另外一种叫作动态作用域

7.无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处 的位置决定

8.事实上 JavaScript 并不具有动态作用域。它只有词法作用域。主要区别：词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定 的。（this 也是！）词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。


9.this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调 用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式, this 既不指向函数自身也不指向函数的词法作用域
this绑定，
（1）默认绑定，指向全局对象，在严格模式下不会指向全局对象
（2）隐式绑定，当函数引 用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象
隐式丢失：一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式
（3）显示绑定：call和apply, 硬绑定

~~~
function bind(fn, obj) {
return function() {
return fn.apply( obj, arguments ); }; }
~~~

（4）new绑定，产生一个新的对象

使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 1. 创建（或者说构造）一个全新的对象。 2. 这个新对象会被执行 [[ 原型 ]] 连接。 3. 这个新对象会绑定到函数调用的 this。 4. 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象

显式绑定优先级更高， new 绑定比隐式绑定优先级高，new调用比显式绑定优先级高

1. 函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。
2. 函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是 指定的对象。
3. 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上 下文对象。
4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到 全局对象。
如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值 在调用时会被忽略，实际应用的是默认绑定规则
箭头函数的绑定无法被修改。（new 也不 行！）

在 JavaScript 中创建一个空对象最简单的方法都是 Object.create(null)
