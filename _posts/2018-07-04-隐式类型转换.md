---
layout: post
title: 隐式类型转换
---

我们在写js的过程中，经常会用到js的表达式，js在判断或者表达式中，经常会用到‘==’或者‘===’，年轻的时候多喜欢用‘==’，觉得即使类型不同，两者也能比较出结果，在使用过程中，难以避免遇到一些隐式类型转换的问题，比如最常见的：

~~~
 0 == '0'
 // true

 '0' == false
 //true
~~~

如果比较的两者中有布尔值，会把布尔值先转换为对应的number，即0或1，如果比较的双方中有一方为number一方为string，会把string转换为数字，把string直接转换为bool的时候，空字符串‘’转换为 false，除此外的一切字符串转换为true。所以我们会看到一个奇怪的景象

~~~
'0' == false
// true

if('0') {
  console.log(111);
}
// 111
~~~

其实这并不难理解，'0'和false比较时，会把false转成0，相当于0与'0'比较，这时，0会转化为'0'，转换之后即相等。而字符串转布尔值时，默认会把除空字符以外的值都转化为true，规则和两方比较的不同。

除了比较，表达式中也常常发生隐式类型转换

~~~
console.log(0 + ''); // 数字0转变为字符串0
console.log(+'0', -'0'); // 字符串转变为数字0
~~~

数字转字符串只需要用‘+’和字符串连接就可以了，在字符串前面加加减符号，可以隐式转换为数字，这种方式在日期转时间戳中也有应用

~~~
+new Date()
~~~

上述代码可以返回当前日期的数字时间戳。这些都是比较简单的隐式转换，Object的转换就稍微复杂一点

~~~
[] == ![]  // true
[] + {};  // "[Object Object]"
{} + []  // 0
~~~

[]会进行布尔值的强制类型转换，所以 ![] 变成了 false，而 [] == false，所以就会返回 true；{} 会被当成一个值（[object, Object]）来处理，而 [] 会转换为 “”。而第三行代码中，{} 被当做一个空的代码块，而 [] 被强制转换为了 0，所以才会出现上面这样的情况；
