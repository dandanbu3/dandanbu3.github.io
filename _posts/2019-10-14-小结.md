---
layout: post
title: 小结
---

1.上可以说 JavaScript 是解释型的，因为每次执行 JavaScript 源码时都需要进行处理。但这么说并不完全精确。JavaScript 引擎实际上是动态编译程序，然后立即执行编译后的代码。

2.强制类型转换
• 如果要比较的两个值的任意一个(即一边)可能是 true 或者 false 值，那么要避免使 用 ==，而使用 ===。
• 如果要比较的两个值中的任意一个可能是特定值(0、"" 或者 []——空数组)，那么避 免使用 ==，而使用 ===。
• 在所有其他情况下，使用 == 都是安全的。不仅仅只是安全而已，这在很多情况下也会 简化代码，提高代码的可读性。

3.无论 var 出现在一个作用域中的哪个位置，这个声明都属于整个作用域，在其中到处都是 可以访问的。这一行为被比喻地称为提升(hoisting)

4.如果只想要运行某个 case 下的语句，那么 break 是很重要的。如果某个 case 省略了 break，而这个 case 匹配或运行的话，那么会一直执行到下一个 case 的语句，不管那个 case 是否匹配。这种所谓的“通过(fall through)”有时是很有用的。

5.当 ... 用在数组之前时（实际上是任何 iterable，我们将在第 3 章中介绍），它会把这个变量“展开”为各个独立的值。
~~~
function foo(x,y,z) {
 console.log( x, y, z );
}
foo( ...[1,2,3] ); // 1 2 3
~~~
... 也可以在其他上下文中用来展开 / 扩展一个值

~~~
var a = [2,3,4];
var b = [ 1, ...a, 5 ];
console.log( b ); // [1,2,3,4,5]
~~~

... 的另外一种常见用法基本上可以被看作反向的行为；与把一个值展开不同，... 把一系列值收集到一起成为一个数组。注意这时候只能放最后一个。
~~~
function foo(x, y, ...z) {
 console.log( x, y, z );
}
foo( 1, 2, 3, 4, 5 ); // 1 2 [3,4,5]
~~~
在赋初始值时，null会被强制转化为0。
~~~
function foo(x = 11, y = 31) {
 console.log( x + y );
}
foo( null, 6 ); // 6 <-- null被强制转换为0
~~~

ES6 为解构新增了一个专门语法，专用于数组解构和对象解构。如果属性名和要赋值的变量名相同，可以省略。
注意，如果省略了 var/let/const 声明符，就必须把整个赋值表达式用 ( ) 括起来。因为如果不这样做，语句左侧的 {..} 作为语句中的第一个元素就会被当作是一个块语句而不是一个对象。

对象解构形式允许多次列出同一个源属性

~~~
var { a: X, a: Y } = { a: 1 };
X; // 1
Y; // 1
~~~
