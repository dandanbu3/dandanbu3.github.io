---
layout: post
title: 小结
---

1.上可以说 JavaScript 是解释型的，因为每次执行 JavaScript 源码时都需要进行处理。但这么说并不完全精确。JavaScript 引擎实际上是动态编译程序，然后立即执行编译后的代码。

2.当 ... 用在数组之前时（实际上是任何 iterable，我们将在第 3 章中介绍），它会把这个变量“展开”为各个独立的值。
~~~
function foo(x,y,z) {
 console.log( x, y, z );
}
foo( ...[1,2,3] ); // 1 2 3
~~~
... 也可以在其他上下文中用来展开 / 扩展一个值

~~~
var a = [2,3,4];
var b = [ 1, ...a, 5 ];
console.log( b ); // [1,2,3,4,5]
~~~

... 的另外一种常见用法基本上可以被看作反向的行为；与把一个值展开不同，... 把一系列值收集到一起成为一个数组。注意这时候只能放最后一个。
~~~
function foo(x, y, ...z) {
 console.log( x, y, z );
}
foo( 1, 2, 3, 4, 5 ); // 1 2 [3,4,5]
~~~
在赋初始值时，null会被强制转化为0。
~~~
function foo(x = 11, y = 31) {
 console.log( x + y );
}
foo( null, 6 ); // 6 <-- null被强制转换为0
~~~

ES6 为解构新增了一个专门语法，专用于数组解构和对象解构。如果属性名和要赋值的变量名相同，可以省略。
注意，如果省略了 var/let/const 声明符，就必须把整个赋值表达式用 ( ) 括起来。因为如果不这样做，语句左侧的 {..} 作为语句中的第一个元素就会被当作是一个块语句而不是一个对象。

对象解构形式允许多次列出同一个源属性

~~~
var { a: X, a: Y } = { a: 1 };
X; // 1
Y; // 1
~~~
