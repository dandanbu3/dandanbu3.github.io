---
layout: post
title: 继承实现方法
---

1.原型链
􏳨􏱛利用原型让一个引用类型继承另外一个引用类型的属性和方法，􏰏􏰜􏰖􏰙原型链在数据为引用类型时容易出现问题，修改引用类型会使其他实例产生改动
~~~
function SuperType () {
  this.property = true;
}
SuperType.prototype.getSuperValue = function () {
  return this.property;
}
function SubType () {
  this.subproperty = false;
}

SubType.prototype = new SuperType();

SubType.prototype.getSubValue = function () {
  return this.subproperty;
}

var instance = new SubType();
console.log(instance.getSuperValue()); //true
~~~

上面代码有个问题， SubType 的 constructor 实际上指向的 SuperType 。

2.借用构造函数
在子类型函数内部调用超类型构造函数,利用 call() 或者 apply() 方法可以在新构建的对象上执行构造函数。
~~~
function SuperType () {
  this.colors = ['red', 'blue', 'green'];
}

function SubType () {
  SuperType.call(this);
}

var instance1 = new SubType();
instance1.colors.push('black');
console.log(instance1.colors); // 'red,blue,green,black'

var instance2 = new SubType();
console.log(instance2.colors); // 'red,blue,green'
~~~

相对原型链的形式，借用构造函数可以在其中传递参数，但其实方法都定义了一遍。

3.组合继承
将原型链继承和借用构造函数继承组合到一起，发挥二者的长处，使用原型链实现原型属性和方法的继承，借用构造函数实现实例属性的继承。
~~~
function SuperType (name) {
  this.name = name;
  this.colors = ['red', 'blue', 'green'];
}

SuperType.prototype.sayName = function () {
  console.log(this.name);
}

function SubType (name, age) {
  SuperType.call(this, name);
  this.age = age;
}
SubType.prototype = new SuperType();
SubType.prototype.constructor = SubType;
SubType.prototype.sayAge = function () {
  console.log(this.age);
}

var instance1 = new SubType('male', 26);
instance1.colors.push('black');
console.log(instance1.colors); //'red,blue,green,black'
instance1.sayName(); // 'male'
instance1.sayAge(); // 26

var instance2 = new SubType('female', 24);
console.log(instance2.colors); //'red,blue,green'
instance2.sayName(); // 'female'
instance2.sayAge(); // 24
~~~

4.原型式继承
ES6 可以通过 Object.create 实现
