---
layout: post
title: 数据结构
---

1.栈是一种高效的数据结构，后入先出（LIFO）
2.栈可以轻松实现进制转换
3.队列是一种特殊的列表，队尾插元素，队首删元素，是一种先进先出（FIFO）

4.优先队列，一般来说，先进先出，在优先队列需要考虑优先权的问题，优化dequeue函数，删除元素时遍历队列删除优先级最高的元素
5.双向队列，可以在双向进行添加和删除
6.链表，基于对象实现，链表是一组节点组成的集合，每个节点都有一个引用指向下一个节点，链表尾元素指向null
7.字典，以键值对的形式存储数据的数据结构，以Array为原型

~~~
function Dictionary() {
this.add = add; this.datastore = new Array(); this.find = find;
        this.remove = remove;
        this.showAll = showAll;
     }
     function add(key, value) {
        this.datastore[key] = value;
}
     function find(key) {
        return this.datastore[key];
}
     function remove(key) {
        delete this.datastore[key];
}
function showAll() {
       for(var key in Object.keys(this.datastore)) {
          print(key + " -> " + this.datastore[key]);
       }
}
~~~

8.散列的数据结构称为散列表
9.一个高效的散列函数，仍然存在将两个键映射成同一个值的可能，这种现象称为碰撞

~~~
// 散列函数
function HashTable() {
        this.table = new Array(137);
        this.simpleHash = simpleHash;
        this.showDistro = showDistro;
        this.put = put;
        //this.get = get;
}
function put(data) {
        var pos = this.betterHash(data);
        this.table[pos] = data;
     }
     function simpleHash(data) {
        var total = 0;
        for (var i = 0; i < data.length; ++i) {
           total += data.charCodeAt(i);
        }
        print("Hash value: " + data + " -> " + total);
        return total % this.table.length;
     }
     function showDistro() {
        var n = 0;
for (var i = 0; i < this.table.length; ++i) { if (this.table[i] != undefined) {
              print(i + ": " + this.table[i]);
           }
} }
     function betterHash(string) {
        const H = 37;
        var total = 0;
        for (var i = 0; i < string.length; ++i) {
           total += H * total + string.charCodeAt(i);
        }
        total = total % this.table.length;
        if (total < 0) {
           total += this.table.length-1;
        }
        return parseInt(total);
     }
~~~

10.散列表，在散列函数基础上修改，将put函数改为键值对形式

~~~
function put(key, data) {
        var pos = this.betterHash(key);
        this.table[pos] = data;
}
~~~

11.散列表解决碰撞，开链法和线性探测法，
开链法：开链法是指实现散列表的底层数组中，每个数组 元素又是一个新的数据结构，比如另一个数组，这样就能存储多个键了
线性探测法：线性探测法隶属于一种更一般化的散列技术：开放 寻址散列。当发生碰撞时，线性探测法检查散列表中的下一个位置是否为空。如果为空， 就将数据存入该位置；如果不为空，则继续检查下一个位置，直到找到一个空的位置为 止。

12.集合（set）是一种包含不同元素的数据结构。集合中的元素称为成员。集合的两个最重 要特性是：首先，集合中的成员是无序的；其次，集合中不允许相同成员存在。
13.不包含任何成员的集合称为空集，全集则是包含一切可能成员的集合。 • 如果两个集合的成员完全相同，则称两个集合相等。 • 如果一个集合中所有的成员都属于另外一个集合，则前一集合称为后一集合的子集
