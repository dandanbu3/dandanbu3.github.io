---
layout: post
title: 小结
---

1.鉴别Promise：鸭子类型，是否具有then函数。即使是立即完成的 Promise 也无法被同步观察到。也就是说，对一个 Promise 调用 then(..) 的时候，即使这个 Promise 已经决议，提供给then(..) 的回调也总会被异步调用

2. Promise.resolve(..) 得到的是一个真正的 Promise，是一个可以信任的值。如果你传入的已经是真正的 Promise，那么你得到的就是它本身，所以通过 Promise.resolve(..) 过滤来获得可信任性完全没有坏处。

这种方式可以实现的关键在于以下两个 Promise 固有行为特性：
• 每次你对 Promise 调用 then(..)，它都会创建并返回一个新的 Promise，我们可以将其链接起来；
• 不管从 then(..) 调用的完成回调（第一个参数）返回的值是什么，它都会被自动设置为被链接 Promise（第一点中的）的完成。

3.then(null,function(err){ .. }) 这个模式——只处理拒绝（如果有的话），但又把完成值传递下去——有一个缩写形式的 API：catch(function(err)
{ .. })。

4.若向Promise.all([ .. ])传入空数组，它会立即完成，但Promise. race([ .. ])会挂住，且永远不会决议

5.在 Worker 内部是无法访问主程序的任何资源的。这意味着你不能访问它的任何全局变量，也不能访问页面的 DOM 或者其他资源
• 处理密集型数学计算
• 大数据集排序
• 数据处理（压缩、音频分析、图像处理等）
• 高流量网络通信
用 Transferable 对象，这时发生的是对象所有权的转移，数据本身并没有移动。一旦你把对象传递到一个 Worker 中，在原来的位置上，它就变为空的或者是不可访问的，这样就消除了多线程编程作用域共享带来的混乱。

6.单指令多数据（SIMD）是一种数据并行（data parallelism）方式，与 Web Worker 的任务并行（task parallelism）相对，因为这里的重点实际上不再是把程序逻辑分成并行的块，而是并行处理数据的多个位。

7.对 JavaScript 性能影响最大的因素是内存分配、垃圾收集和作用域访问。

8.benchmark.js 用于测试代码性能

9.jsPerf.com 交叉使用多个浏览器进行测试

10.把 JavaScript 代码看作对引擎要做什么的提示和建议，而不是逐字逐句的要求时，你就会意识到，对于具体语法细节的很多执着迷恋已经烟消云散了。

11.，ES6 包含了一个性能领域的特殊要求。这与一个涉及函数调用的特定优化形式相关：尾调用优化（Tail Call Optimization，TCO）。

~~~
function foo(x) {
 return x;
}
function bar(y) {
 return foo( y + 1 ); // 尾调用
}
function baz() {
 return 1 + bar( 40 ); // 非尾调用
}
baz(); // 42
~~~
简单地说，尾调用就是一个出现在另一个函数“结尾”处的函数调用。这个调用结束后就没有其余事情要做了（除了可能要返回结果值）。
使用尾调用的递归性能不受影响
