---
layout: post
title: 小结
---


1.一元运算符 ! 显式地将值强制类型转换为布尔值。但是它同时还将真值反转为假值(或者将假值反转为真值)。所以显式强制类型转换为布尔值最常用的方法是 !!。

2.在 if(..).. 这样的布尔值上下文中，如果没有使用 Boolean(..) 和 !!，就会自动隐式地进 行 ToBoolean 转换。

3.如果 + 的其中一个操作数是字符串(或者通过以上步骤可以得到字符串)， 则执行字符串拼接;否则执行数字加法

4.|| 和 && 首先会对第一个操作数(a 和 c)执行条件判断，如果其不是布尔值(如上例)就 先进行 ToBoolean 强制类型转换，然后再执行条件判断。
对于 || 来说，如果条件判断结果为 true 就返回第一个操作数(a 和 c)的值，如果为 false 就返回第二个操作数(b)的值。
&& 则相反，如果条件判断结果为 true 就返回第二个操作数(b)的值，如果为 false 就返 回第一个操作数(a 和 c)的值。

5.ES6 允许 从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误

~~~
var s1 = Symbol( "cool" );
String( s1 );     // "Symbol(cool)"
var s2 = Symbol( "not cool" );
s2 + "";      // TypeError
~~~

6.== 允许在相等比较中进行强制类型转换，而 === 不允许。

7.强制类型转换

(1)如果Type(x)是数字，Type(y)是字符串，则返回x == ToNumber(y)的结果。
(2)如果Type(x)是字符串，Type(y)是数字，则返回ToNumber(x) == y的结果。
(3)如果Type(x)是布尔类型，则返回ToNumber(x) == y的结果;
(4)如果Type(y)是布尔类型，则返回x == ToNumber(y)的结果。
(5) 如果 x 为 null，y 为 undefined，则结果为 true。
(6) 如果 x 为 undefined，y 为 null，则结果为 true。
(7)如果Type(x)是字符串或数字，Type(y)是对象，则返回x == ToPrimitive(y)的结果;
(8)如果Type(x)是对象，Type(y)是字符串或数字，则返回ToPromitive(x) == y的结果。
(9)""、"\n"(或者 " " 等其他空格组合)等空字符串被 ToNumber 强制类型转换为 0

8.语句和表达式在英语中都能找到类比——语句就像英语中的句子，而表达式就像短语。表 达式可以是简单独立的，否则可能会产生副作用。
JavaScript 语法规则之上是语义规则(也称作上下文)。例如，{ } 在不同情况下的意思不 尽相同，可以是语句块、对象常量、解构赋值(ES6)或者命名函数参数(ES6)。
JavaScript 详细定义了运算符的优先级(运算符执行的先后顺序)和关联(多个运算符的 组合方式)。只要熟练掌握了这些规则，就能对如何合理地运用它们作出自己的判断。
ASI(自动分号插入)是 JavaScript 引擎的代码解析纠错机制，它会在需要的地方自动插 入分号来纠正解析错误。问题在于这是否意味着大多数的分号都不是必要的(可以省略)， 或者由于分号缺失导致的错误是否都可以交给 JavaScript 引擎来处理。
JavaScript 中有很多错误类型，分为两大类:早期错误(编译时错误，无法被捕获)和运 行时错误(可以通过 try..catch 来捕获)。所有语法错误都是早期错误，程序有语法错误 则无法运行。
函数参数和命名参数之间的关系非常微妙。尤其是 arguments 数组，它的抽象泄漏给我们 挖了不少坑。因此，尽量不要使用 arguments，如果非用不可，也切勿同时使用 arguments 和其对应的命名参数。
finally 中代码的处理顺序需要特别注意。它们有时能派上很大用场，但也容易引起困惑， 特别是在和带标签的代码块混用时。总之，使用 finally 旨在让代码更加简洁易读，切忌 弄巧成拙。
switch 相对于 if..else if.. 来说更为简洁。需要注意的一点是，如果对其理解得不够透 彻，稍不注意就很容易出错。
